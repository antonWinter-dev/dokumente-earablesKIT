\documentclass[a4paper,12pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[utf8]{inputenc} % Umlaute
\usepackage[ngerman]{babel} % Umlaute
\usepackage[T1]{fontenc}    % Umlaute
\usepackage[margin=2.5cm]{geometry}
\usepackage{booktabs}
\usepackage{lmodern}
\usepackage{titlesec}
\usepackage{longtable}
% Notwendig für Links im Text
\usepackage{hyperref}
%%\usepackage{svg}
% glossar, see http://en.wikibooks.org/wiki/LaTeX/Glossary
% muss NACH hyperref geladen werden, sonst funktionieren die Links nicht
\usepackage[toc]{glossaries}

% Kompatibilität
\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
\usepackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi
\setlength{\parindent}{0pt}


%irgendwas mit section formatierung (titlesec package)
\titleformat{\paragraph}[hang]{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Variablen                                 						 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\authorName}{Tec O'Brain (Entwickler: David Höglinger, Jan Ettrich, Erwin Müller, Benedikt Rittner, Valentin Quapil)}
\newcommand{\auftraggeber}{Karlsruhe Institute of Technology (Teco)}
\newcommand{\auftragnehmer}{\authorName}
\newcommand{\projektName}{Implementierung Earables}
\newcommand{\tags}{\authorName, Architektur, Implementierung, KIT, Informatik, PSE}
\newcommand{\documentVersion}{1.0}
\title{\projektName}
\date{\today}
\author{Tec O'Brain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PDF Meta information                                 				 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypersetup{
  pdfauthor   = {\authorName},
  pdfkeywords = {\tags},
  pdftitle    = {\projektName)}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create a shorter version for tables. DO NOT CHANGE               	 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\addrow[2]{#1 &#2\\ }

\newcommand\addheading[2]{#1 &#2\\ \hline}
\newcommand\tabularhead{\begin{tabular}{lp{13cm}}
\hline
}

\newcommand\addmulrow[2]{ \begin{minipage}[t][][t]{2.5cm}#1\end{minipage}%
   &\begin{minipage}[t][][t]{8cm}
    \begin{enumerate} #2   \end{enumerate}
    \end{minipage}\\ }

\newenvironment{usecase}{\tabularhead}
{\hline\end{tabular}}

\usepackage{microtype}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GLOSSARY ENTRIES                 	                              	 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE DOCUMENT BEGINS             	                              	 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\pagenumbering{roman}
\input{Deckblatt}         % Deckblatt.tex laden und einfügen
\setcounter{page}{2}
\tableofcontents          % Inhaltsverzeichnis ausgeben
\clearpage
\pagenumbering{arabic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONTENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Einleitung}
%%%%%%%%%%%%%%%%%%%%%% !!!!!!!!!!!!  struktur - Schema (runde Klammern = optional)
%
\section{Schema für Probleme und Änderungen am Entwurf}
\subsection{<<Bereich>>}
\subsubsection{<<Um was geht es>>}
\paragraph{Beschreibung}
<<Beschreibung>>
\paragraph{
  Änderung(en) (von ...) in Klasse(n) ... \\
  ODER \\
  Ergänzung(en) (von ...) in Klasse(n)... \\
  ODER \\
  Entfernen (von ...) in Klasse(n) ... (was nie vorkommt glaube ich) }
(<<kurze Erläuterung>>)
\begin{itemize}
  \item[+ ODER $-$] <<neues Attribut in UML-Notation>> (bei komplettem Austausch von z.B. Methode und Property: \textit{ersetzt} <<altes Attribut>>)
\end{itemize}
%
%%%%%%%%%%%%%%%%%%%%%%%%%% !!!!!!!!!!!!!!!

\section{Probleme und Änderungen am Entwurf}
\subsection{Bibliothek}

\subsubsection{Umgang mit Exceptions}
\paragraph{Beschreibung}
Es war geplant, dass die meisten Schnittstellen der Bibliothek ein Boolean zurückgeben, der true ist, falls die Anweisung korrekt durchgeführt werden konnte und false , falls es Komplikationen gab.\\
Um besser auf Fehler und Exceptions zu reagieren macht es mehr Sinn, dass diese Methoden nichts zurückgeben sind und im Fehlerfall Exceptions schmeißen.\\
Dies wurde umgesetzt, falls sich der Nutzer der Schnittstelle IEarablesConnection mehrmals verbinden will, keine Verbindung aufgebaut werden konnte, eine ungültige SampleRate angegeben wurde (Werte zwischen 1 und 100 sind erlaubt) oder eine Aktion ausgeführt werden soll, die bereits eine Verbindung voraussetzt, aber es existiert keine Verbindung.

\paragraph{Änderungen in Klasse IEarablesConnection}
Folgende Methoden haben nicht mehr den Rückgabetypen bool sondern void und schmeißen im Fehlerfall Exceptions:
\begin{itemize}
	\item[+] DisconnectFromDevice(): bool
	\item[+] StartSampling(): bool
	\item[+] StopSampling(): bool
\end{itemize} 
\paragraph{Hinzugefügte Exceptions}
Folgende Exception-Klassen mussten ergänzt werden:
\begin{itemize}
	\item[$-$] AllreadyConnectedException
	\item[$-$] ConnectionFailedException
	\item[$-$] InvalideSampleRateException
	\item[$-$] NoConnectionException.%man könnte noch überlegen die Rechtschreibfehler aus den AlreadyConnectedException und InvalidSampleRateException raus zu nehmen, müsste man dann aber auch konsequent im code so machen.
\end{itemize}
Die Exceptions werden geschmissen, falls bereits ein Gerät verbunden ist, keine Verbindung aufgebaut werden kann, der Wert der eingegebenen Samplerate nicht im richtigen Bereich (zwischen 1 und 100) liegt oder keine Verbindung vorhanden ist, diese aber benötigt würde (z.B. um das Sampling zu starten).

\subsubsection{Properties eingeführt}
\paragraph{Beschreibung}
\paragraph{Änderungen in Klasse IEarablesConnection}
In einigen Fällen gibt es nun keine Get/Set Methoden mehr. Sie wurden durch Properties ersetzt.
Folgende Properties sind als Attribute dazugekommen:
\begin{itemize}
	\item[+] Connected (\textit{ersetzt } die Methode IsConnected(): bool)
	\item[+] IsBluetoothActive  (\textit{ersetzt } die Methode IsBleutoothActive(): bool)
	\item[+] SampleRate  \textit{ersetzt } die Methode SetSamplingrate(heat: int): bool)
	\item[+] AccLPF  (\textit{ersetzt} SetLowPassFilterAccelerometer, GetLowPassFilterAccelerometer)
	\item[+] GyroLPF  (\textit{ersetzt} SetLowPassFilterGyroscope, GetLowPassFilterGyroscope)
	\item[+] BatteryVoltage  (\textit{ersetzt } die Methode GetBatteryVoltage(): float)
\end{itemize}

\paragraph{Hinzugefügt in Klasse EarablesConnection}
Zusätzlich zu den vererbten Änderungen ergeben sich folgende neue private Methoden:
\begin{itemize}
	\item[$-$] CheckIsBluetoothActive(): void
	\item[$-$] GetAccelerometerLPF(): LPF\_Accelerometer
	\item[$-$] SetAccelerometerLPF(LPF\_Accelerometer value): void
	\item[$-$] GetGyroscopeLPF(): LPF\_Gyroscope
	\item[$-$] SetGyroscopeLPF(LPF\_Gyroscope value): void
	\item[$-$] GetBatteryVoltageFromDevice(): void
	\item[$-$] initBatteryVoltage(): Task
\end{itemize}
  Hierbei wird GetBatteryVoltageFromDevice automatisch aufgerufen, wenn sich die BatteryVoltage der Earables ändert und überträgt den aktuellen Wert in das BatteryVoltage Attribut.\\
  Die Methode initBatteryVoltage liest den BatteryVoltage Wert der Earables zum ersten Mal aus, falls sie abgefragt werden sollte, bevor sie sich das erste Mal aktualisiert hat.

\subsubsection{Kapselung von Attributen der Bibliothek}
\paragraph{Beschreibung}
Für die Attribute config und characteristics ist es in Betracht der Datenkapselung sinnvoller, sie private zu halten. Sie werden von außen nicht direkt benötigt.
\paragraph{Änderungen in Klasse IEarablesConnection}
\begin{itemize}
	\item[$-$] config
	\item[$-$] characters
\end{itemize}


\subsubsection{Namensänderungen bei Enums}
\paragraph{Beschreibung}
Die Enums können nicht mit Zahlen beginnen. Daher mussten sie umbenannt werden.
\paragraph{Änderungen in den Enums LPF\_Accelerometer und LPF\_Gyroscope}
Die Werte der Enums beginnen nun nicht mehr mit der Zahl sondern mit Hz. \\
Beispielsweise wird statt 10Hz jetzt Hz10 verwendet.

\subsubsection{Übergabe der Geräte beim Scanvorgang}
\paragraph{Beschreibung}
Es war ursprünglich gedacht, dass die StartScanning Methode eine Liste mit alle gefundenen Devices zurück gibt. Die Liste, die zurückgegeben wurde war aber immer leer, da Methoden aus dem Plugin BLE benutzt wurden, die asynchron laufen. So wurde zuerst die Liste zurückgegeben und danach wurde sie befüllt. Nach etlichen gescheiterten Versuchen auf die Threads und Tasks zu warten haben wir uns dafür entschieden jedes Mal ein Event zu schmeißen, wenn ein neues Device gescannt wurde. Die Argumente des Events beinhalten das neue Device.
\paragraph{Änderungen in der Klasse IEarablesConnection}
Hinzugefügt wurde:
\begin{itemize}
	\item[+] event NewDeviceFound: EventHandler<NewDeviceFoundArgs> 
\end{itemize}
\paragraph{Klasse NewDeviceFound hinzugefügt}
\begin{itemize}
	\item[+] Device: IDevice
	\item[+] <<create>> NewDeviceFound(device :IDevice)
\end{itemize}

\subsubsection{Static Methoden in der Klasse IEarablesConnection}
\paragraph{Beschreibung}
Es wurde angenommen, dass die Methoden, die auf die Events der Earables reagieren static sein müssen. Diese Annahme war falsch.
\paragraph{Änderungen in der Klasse IEarablesConnection}
Die folgenden Methoden sind nun nicht mehr statisch:
\begin{itemize}
  \item[+]OnValueUpdatedIMU():void
  \item[+]OnPushButtonPressed():void
  \item[+]OnDeviceConnected():void 
\end{itemize}


\subsubsection{Reaktion auf Verbinden und Trennen von Devices}
\paragraph{Beschreibung}
Es wurden zwei Methoden hinzugefügt, um den Connectionstate des Smartphones mit Hilfe des DeviceConnectionStateChanged Events weiterzuleiten.\\
 Sie werden aktiviert, wenn sich die Earables mutwillig vom Device trennen oder die Verbindung unterbrochen wird.
\paragraph{Ergänzungen in der Klasse EarablesConnection}

\begin{itemize}
	\item[-] OnDeviceDisconnected(object sender, DeviceEventArgs args): void 
	\item[-] OnDeviceConnectionLost(object sender, DeviceErrorEventArgs args): void
\end{itemize}

\subsubsection{Funktionsweise der Klasse IMUDataExtractor}
\paragraph{Beschreibung}
Hier waren aus verschiedenen Gründen Änderungen nötig: 
Die Methode ExtractIMUDataString benötigt für die Berechnung der Sensordaten zusätzlich noch den Offset. Dieser wird nun als vierter Parameter übergeben.\\
 Die Skalierungsfaktoren, die als Parameter übergeben werden können nicht nur ganzzahlig sein, hier sind Fließkommazahlen sinnvoller.\\
Die Klasse wurde der Vollständigkeit halber um zwei Methoden ergänzt, die die Range des Accelerometers und des Gyroscopes aus dem entsprechenden Bytearray ermitteln.
\paragraph{Änderungen in der Klasse IMUDataExtractor}
\begin{itemize}
  \item[+] \underline{ExtractIMUDataString(byteString: int, accScaleFactor: double,} \\
  \underline{GyroScaleFactor: int, byteOffset: byte[])} 
	\item[+] \underline{ExtractIMUScaleFactorAccelerometer(byteString: int): double}
	\item[+] \underline{ExtractIMUScaleFactorGyoscope(byteString: int): int}
\end{itemize}
\paragraph{Ergänzungen in der Klasse IMUDataExtractor}
\begin{itemize}
  \item[+] \underline{ExtractIMURangeAccelerometer(byte[] bytes): int} 
	\item[+] \underline{ExtractIMURangeGyroscope(byte[] bytes): double} 
\end{itemize}
%durchlesen valle ab hier
\subsubsection{Charakteristik umbenannt}
\paragraph{Beschreibung}
Eine Charakteristik wurde umbenannt.
\paragraph{Änderungen in der Klasse Constants}
\begin{itemize}
	\item[+] Attribut IMU\_FULL\_SCALE\_RANG\_CHAR in OFFSET\_CHAR umbenannt.
\end{itemize}
\paragraph{Änderungen in der Klasse Characteristics}
\begin{itemize}
	\item[+] Attribute IMUScaleRangeChar in OffsetChar umbenannt.
\end{itemize}

\subsubsection{Connection überprüfung}
\paragraph{Beschreibung}
Um festzustellen ob eine Verbindung zu einem Device besteht wurde eine Methode hinzugefügt
\paragraph{Ergänzungen in der Klasse EarablesConnection}
\begin{itemize}
	\item[-]  CheckConnection():void  
\end{itemize}
Sie wird am Anfang aller  Methode, die eine Verbindung voraussetzen, aufgerufen und prüft ob eine Verbindung existiert. Falls keine existiert schmeißt sie eine die Exception NoConnectionException.

\subsubsection{Klasse ConfigContainer um Attribute ergänzt}
\paragraph{Beschreibung}
Um das Bytearray des IMU auszuwerten benötigt man die Scalefactoren für den Accelerometer und für das Gyroscope. Wenn man diesen aber erst in der Methode OnValueUpdatedIMU ausliest stürzt die App ab, da die Methode jedes mal aufgerufen wird, wenn neue IMUDaten anliegen, was bis zu 100 mal pro Sekunde passieren kann. Das liegt daran, dass das Auslesen der Charakteristiken mit Hilfe von asynchronen Methoden aus dem Plugin.BLE geschieht. Deswegen werden die Scalefactoren bereits beim Starten des Samplings ausgelesen und müssen irgendwo zwischengespeichert werden. Dafür wurden in der Klasse ConfigContainer zwei Attribute AccScaleFactor und GyroScaleFactor hinzugefügt. Außerdem enthält sie zusätzlich noch eine Methode um zu überprüfen, ob die Samplingrate im gültigen Wertebereich liegt.
\paragraph{Ergänzungen in der Klasse ConfigContainer}
\begin{itemize}
	\item[+] AccScaleFactor: int 
	\item[+] GyroScaleFactor: int
	\item[$-$]  setSamplingRate(int rate): void 
\end{itemize}
Beim setzten des Samplingrate Propertys wird die Methode setSamplingRate ausgeführt und stellt sicher, dass nur gültige Werte angenommen werden.

\subsubsection{Testmethoden hinzugefügt}
\paragraph{Beschreibung}
Die Scalefactoren hängen von der gewählten Range des Accelerometers und des Gyroscopes ab. Um zu testen ob der richtige Wert in die  Earables geschrieben wird gibt es nun zusätzlich zwei Methoden, die die Range setzen und weitere zwei um die Range von den Earables zu lesen.
Außerdem wird beim setzen der LPF, in den configs gespeichert auf welchen Wert sie momentan gesetzt sind. Beim Auslesen wird also nicht der Wert von den Earables gelesen sonder der Wert der in den configs steht. Das hat den selben Grund weshalb wir die gefundenen Devices, beim scannen, nicht als Liste zurückgeben. Um den aktuellen LPF der Earables auszulesen benutzen wir wieder asynchrone Methoden aus dem Plugin.BLE. Das heißt der Wert des LPF wird erst zurückgegeben und dann erst ausgelesen, was das Ergebnis verfälscht. Um das zu vermeiden werden die Werte für die LPF nicht aus den Earables ausgelesen sondern aus den Configs, in denen sie gespeichert wurden. Für Testzwecke wurden jedoch trotzdem zwei Methoden implementiert, die die Werte für die LPF direkt aus den Earables lesen. Diese Methoden werden auch in der BibTestApp zum auslesen verwendet.

\paragraph{Ergänzungen in der Klasse EarablesConnection}
\begin{itemize}
	\item[$-$] setAccelerometerRange(range :int): void
	\item[$-$] setGyroscopeRange(range: int): void
	\item[$-$ ] getAccelerometerLPFFromDevice(): void
	\item[$-$ ] getGyroscopeLPFFromDevice(): void
\end{itemize}
Ermöglichen es die Range zu setzen und den LPF aus den Earables auszulesen. Die Methoden um die Range auszulesen befinden sich in der Klasse IMUDataextractor. Die Methoden zum auslesen des  LPF schreiben den LPF in eine Variable. Bei Verwendung dieser Methoden müssen die Variablen vorher global deklariert werden, um auf sie zuzugreifen zu können. Da wir die Methoden nicht benutzen und sie nur zum testen da sind existieren diese globalen Variablen in unsere Bibliothek nicht.
% durchlesen bis hier valle
\subsection{Erweiterungsmodul}

\subsection{Model (andere Bestandteile)}

\subsection{Views und ViewModel}
\subsubsection{Commandstruktur bei Modi}
\paragraph{Beschreibung}
Beim Aktivieren eines Modus' wird per Command direkt das ViewModel aufgerufen. Es muss aber die Seite gewechselt werden und das ViewModel darf die Views nicht kennen. \\
Somit muss der Button-Click in den Code Behind des Views delegiert werden, damit dort der Seitenwechsel implementiert werden kann. Erst von dort aus wird an das ViewModel weitergeleitet.
\paragraph{Änderungen in Klasse BaseModeViewModel}
\begin{itemize}
	\item[-] methodeXY(): void (\textit{ersetzt} CommandXY)
\end{itemize}
\paragraph{Änderungen in Klassen CountViewModel, StepViewModel}
Die Kindklassen ändern sich entsprechend folgendermaßen:
\begin{itemize}
	\item[-] methodeXY() void (\textit{ersetzt} CommandXY)
\end{itemize}
\section{Statistik der Testfälle}

\section{Implementierungsplan}

\section{Anhang}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% END CONTENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\printglossaries
\stepcounter{section}


\end{document}