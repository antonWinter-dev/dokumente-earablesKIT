\documentclass[a4paper,12pt]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[utf8]{inputenc} % Umlaute
\usepackage[ngerman]{babel} % Umlaute
\usepackage[T1]{fontenc}    % Umlaute
\usepackage[margin=2.5cm]{geometry}
\usepackage{booktabs}
\usepackage{lmodern}
\usepackage{titlesec}
% Notwendig für Links im Text
\usepackage{hyperref}

% glossar, see http://en.wikibooks.org/wiki/LaTeX/Glossary
% muss NACH hyperref geladen werden, sonst funktionieren die Links nicht
\usepackage[toc]{glossaries}

% Kompatibilität
\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
\usepackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi

% specify the path to the images
\graphicspath{{bilder/}}

%irgendwas mit section formatierung (titlesec package)
\titleformat{\paragraph}[hang]{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Variablen                                 						 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\authorName}{Tec O'Brain (Entwickler: David Höglinger, Jan Ettrich, Erwin Müller, Benedikt Rittner, Valentin Quapil)}
\newcommand{\auftraggeber}{Karlsruhe Institute of Technology (Teco)}
\newcommand{\auftragnehmer}{\authorName}
\newcommand{\projektName}{Entwurf Earables}
\newcommand{\tags}{\authorName, Architektur, Entwurf, KIT, Informatik, PSE}
\newcommand{\glossarName}{Glossar}
\newcommand{\documentVersion}{0.1}
\title{\projektName}
\date{\today}
\author{Tec O'Brain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PDF Meta information                                 				 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypersetup{
  pdfauthor   = {\authorName},
  pdfkeywords = {\tags},
  pdftitle    = {\projektName)}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create a shorter version for tables. DO NOT CHANGE               	 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand\addrow[2]{#1 &#2\\ }

\newcommand\addheading[2]{#1 &#2\\ \hline}
\newcommand\tabularhead{\begin{tabular}{lp{13cm}}
\hline
}

\newcommand\addmulrow[2]{ \begin{minipage}[t][][t]{2.5cm}#1\end{minipage}%
   &\begin{minipage}[t][][t]{8cm}
    \begin{enumerate} #2   \end{enumerate}
    \end{minipage}\\ }

\newenvironment{usecase}{\tabularhead}
{\hline\end{tabular}}

\usepackage{microtype}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GLOSSARY ENTRIES                 	                              	 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\makeglossaries
\loadglsentries{Glossar.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% THE DOCUMENT BEGINS             	                              	 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\pagenumbering{roman}
 \input{Deckblatt}         % Deckblatt.tex laden und einfügen
 \setcounter{page}{2}
 \tableofcontents          % Inhaltsverzeichnis ausgeben
 \clearpage
 \pagenumbering{arabic}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONTENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Einleitung}
In diesem Dokument wird der Entwurf der \Gls{CPB}, des Erweiterungsmoduls und der App spezifiziert. Außerdem wird die Interaktion der einzelnen Komponenten beschrieben.
Die verwendete Notation richtet sich nach dem UML-Standard.

\section{Aufbau}
    \subsection{Architektur}
    \subsection{Klassendiagramm}


\section{Klassenübersicht}
\section{Klassenbeschreibung Model}
\subsection{ServiceManager}
	\paragraph{Klassenbeschreibung:}
	Der ServiceManager verwaltet alle Services des Models mithilfe eines Serviceproviders. Dies wird von anderen Services des Models, sowie von dem Viewmodel benutzt. Er dient zur Delegierung der Services.\\ 
	Dabei implementiert der ServiceManager das Interface IManager.
	Von diesem bekommt er die Methode serviceRegistration() übergeben.
	Der ServiceManager speichert die Services als Referenzen und achtet, dass diese ein Singleton sind. (Es existiert immer nur eine Instanz des Services).
	Er selbst implementriert das Singleton Muster.
	
	\paragraph{Attribute:}
	\begin{tabular}{p{7cm}p{10cm}}
		- static instance : ServiceManager & Die Singleton Instanz, welche benutzt wird \\
		+ static Instance : ServiceManager & Regelt die Initialisierung von instance und gibt diese zurück\\
		+ serviceProvider : ServiceProvider & Enthält alle Referenzen auf die Services. Per GetService<T> wird der Service vom Typ T zurückgeliefert.\\
	\end{tabular}
	\paragraph{Methoden:}
	\begin{tabular}{p{7cm}p{10cm}}
		- Servicemanager() : void & privater Konstruktor, genutzt im Singleton Muster. Aufrufen der Methode serviceRegistration() zur Erstmaligen Registrierung der Services mit einer IServiceCollection und zur Erstellung des ServiceProvider.\\
	\end{tabular}
		
\subsection{Settings Service}
\subsubsection{User}
    \paragraph{Klassenbeschreibung:}
    Die User-Klasse spezifiziert den Benutzer, der die App gerade verwendet.\\
    \paragraph{Attribute:}
    \begin{tabular}{p{5cm}p{12cm}}
        + username: String & Der Name des Benutzers.\\
        + steplength: String & Die durchschnittliche Schrittlänge des Benutzers in cm.\\
    \end{tabular}
    \paragraph{Methoden:}
    \begin{tabular}{p{7cm}p{10cm}}
        + toString(): String & Wandelt das Objekt in einen String um. (vergleichbar mit JSON).\\
        + static parseUser(user: String): User & Wandelt JSON-String wieder in Objekt um.\\
    \end{tabular}
\subsection{ISettingsService}
	\paragraph{Interfacebeschreibung:}
	Das Interface ISettingsService bietet eine Schnittstelle für die Einstellungen der App. Sie implementiert Konstanten zur Identifizierung der Einstellungen und hält die aktuellen Einstellungen als Attribute.
	\paragraph{Attribute:}
	\begin{tabular}{p{7cm}p{10cm}}
		+ activeLanguage: CultureInfo & Die aktuelle Sprache der App (Deutsch oder Englisch)\\
		+ samplingRate: SamplingRate & Die aktuelle Samplingrate der \Gls{Earables} \\ 
		- LANGUAGE\_PROPERTY: String & Konstanter Bezeichner für die Einstellung der Sprache \\
		- USER\_PROPERTY: String & Konstanter Bezeichner für die Einstellung des Nutzers \\
		- SAMPLINGRATE\_PROPERTY: String & Konstanter Bezeichner für die Einstellung der Samplingrate \\
	\end{tabular}
	\paragraph{Methoden:}
	\begin{tabular}{p{7cm}p{10cm}}
		- loadSettings():void & Lädt alle Settings aus den Einstellungen in die Attribute.	
	\end{tabular}
\subsection{SettingsService}
	\paragraph{Klassenbeschreibung}
	Die Klasse SettingsService implementiert die Schnittstelle ISettingsService. In der Implementierung der Funktionen, welche die Speicherung der Einstellungen enthalten, wird die Klasse App.Current.Properties verwendet.
	Dabei wird immer sofort nach einer Änderung die neue Einstellung gespeichert und nicht erst beim Beenden der Sitzung.
	
	
	TODO: Sollen auch bei den konkreten Klassen die Methoden/Attribute nochmal aufgelistet werden?
\subsection{IDataBaseConnection}
	

\section{Klassenbeschreibung View-Model}
\subsection{StepModeViewmodel}
\paragraph{Klassenbeschreibung:}
Die Klasse CountModeViewmodel enthält die Logik des Stepmodes  und hält Attribute die per Databinding an die Viewklassen CountModeView und CountModeActiveView gebunden sind. 
\paragraph{Attribute:}
\begin{tabular}{p{7cm}p{10cm}}
+ StepsDoneLastTime: string & Hält die Schrittanzahl des letzten aktiven Laufvorgangs. \\
+ DistanceWalkedLastTime: string & Hält die gelaufene Distanz während des letzten aktiven Laufvorgangs. \\
+ LastDatatime: string & Hält das Datum des letzten aktiven Laufvorgangs. \\
+ StepCounter: int & Counter für die Schrittanzahl während des aktiven Laufvorgangs. \\
+ DistanceWalked: int & Bisher gelaufene Distanz. \\
+ isRunning: boolean & True wenn der Nutzer läuft, false wenn er steht. \\
+ StartActivityCommand: Command & Der Command der beim Drücken des Start Buttons ausgeführt wird, um den Laufvorgang zu starten. \\
+ StopActivtiyCommand: Command & Der Command der beim Drücken des Stopp Buttons ausgeführt wird, um den Laufvorgang zu stoppen. \\
\end{tabular}
\paragraph{Methoden:}
\begin{tabular}{p{7cm}p{10cm}}
+ <<create>> StepModeViewmodel() & Konstruktor, in dem die Commands definiert und die Instanz des Service Managers zugewiesen werden. Die Anzahl der zuletzt gelaufenen Schritte und die Distanz sowie das Datum werden durch Aufruf der Methode updateLastData über den ServiceManager von der DatabaseConnection geupdated. isRunning wird standardmäßig zunächst auf false gesetzt.\\
+ StartActivity(): void & Methode die vom StartActivityCommand aufgerufen wird. Holt sich beim Service Manager den ActivityManager, der dann die StepActivity zur Verfügung stellt. Das Viewmodel registriert seine OnActivityDone Event Methode beim Event Handler in der StepActivity Klasse und wechselt zum StepModeActiveView. \\
+ StopActivity(): void & Methode die vom StopActivityCommand aufgerufen wird. Meldet die OnActivityDone Methode vom EventHandler in der StepActivity Klasse ab und setzt isRunning auf false. Zeigt ein PopUp mit der Anzahl der gelaufenen Schritte an, welches der Nutzer wegklicken kann. Danach wird zum StepModeView zurück gewechselt und die Anzeige des letzten Laufvorgangs aktualisiert. \\
+ OnActivityDone(object sender, EventArgs.Empty) & Event Methode, die von der Aktivität bei Erkennung von einem Schritt aufgerufen wird. Sie erhöht den Counter um 1 und setzt isRunning auf True. Ruft danach checkRunning auf \\
+ updateLastData(): void & Wird vom Konstruktor und nach jedem Vorgangsende aufgerufen. Aktualisiert die Attribute StepsDoneLastTime, DistanceWalkedLastTime und LastDatatime, indem über den Service Manager von der DataBaseConnection der letzte Eintrag genommen wird. \\
+ checkRunning(): void & Speichert den aktuellen StepCounter Wert zwischen und vergleicht diesen nach einer Sekunde mit dem neuen StepCounter Wert. Sind diese gleich, so wird isRunning auf false gesetzt. \\
+ showPopUp(): void & Zeigt das PopUp mit den gelaufenen Schritten und der Distanz asynchron an, wegklickbar mit einem Button. \\
\end{tabular}

\subsection{CountModeViewmodel}
\paragraph{Klassenbeschreibung:}
Die Klasse CountModeViewmodel enthält die Logik des Countmodes und hält Attribute die per Databinding an die Viewklassen CountModeView und CountModeActiveView gebunden sind. Sie implementiert die INotifyPropertyChanged Schnittstelle, um das Auswählen einer Aktivität durch den Benutzer in der zugehörigen Viewklasse anzeigen zu können.
\paragraph{Attribute:}
\begin{tabular}{p{7cm}p{10cm}}
+ PropertyChanged: PropertyChangedEventHandler & Der Eventhandler der INotifyPropertyChanged Schnittstelle, bei dem die zugehörige View registriert ist. \\
+ selectedActivity: String & Die aktuell vom Nutzer ausgewählte Aktivität. \\
+ timer: Stopwatch & Der Timer, welcher die Trainingszeit des Nutzers misst. \\
+ counter: int & Ein Zähler, der die Anzahl der ausgeführten Wiederholungen des Nutzers zählt. \\
+ Minutes: String & Anzahl Minuten der Ausführungszeit. \\
+ Seconds: String & Anzahl Sekunden der Ausführungszeit. \\
+ Milliseconds: String & Anzahl Sekunden der Ausführungszeit. \\ 
+ StartActivityCommand: Command & Der Command der beim Drücken des Start Buttons ausgeführt wird, um den Zählvorgang zu starten. \\
+ StopActivityCommand: Command & Der Command der beim Drücken des Stopp Buttons ausgeführt wird, um den Zählvorgang zu stoppen. \\
+ Manager: ServiceManager & Die Instanz des ServiceManagers, bei dem Anfragen an Services getätigt werden. \\
\end{tabular}
\paragraph{Methoden:}
\begin{tabular}{p{7cm}p{10cm}}
+ <<create>> CountModeViewmodel() & Konstruktor, in dem die Commands definiert und die Instanz des Service Managers zugewiesen werden. \\
\# OnPropertyChanged(): void & Methode die beim Eintritt des PropertyChanged Events aufgerufen wird. Sie verändert bei der registrierten View Klasse die Anzeige der ausgewählten Aktivität. \\
+ StartActivity(): void & Methode die vom StartActivityCommand aufgerufen wird. Holt sich beim Service Manager den ActivityManager, der dann die auswählte Activity zur Verfügung stellt. Das Viewmodel registriert seine OnActivityDone Event Methode beim Event Handler in der Activity Klasse und wechselt zum CountModeActiveView; danach wird der Timer gestartet. \\
+ StopActivity(): void & Methode die vom StopActivityCommand aufgerufen wird. Meldet die OnActivityDone Methode vom EventHandler in der Activity Klasse ab und hält den Timer an. Zeigt ein PopUp mit der Anzahl der ausgeführten Aktivität an, welches der Nutzer wegklicken kann. Danach wird zum CountModeView zurück gewechselt. \\
+ StartTimer(): void & Startet den Timer. \\
+ StopTimer(): void & Stoppt den Timer. \\
+ OnActivityDone(): void & Event Methode, die von der Aktivität bei Erkennung der Ausführung von einer Wiederholung aufgerufen wird. Sie erhöht den Counter um 1. \\
+ ShowPopUp(): void & Zeigt das PopUp mit dem Vorgangsresultat asynchron an, wegklickbar mit einem Button. \\
\end{tabular}

\subsection{ListenAndPerformViewmodel}
\paragraph{Klassenbeschreibung:}
Die Klasse ListenAndPerformViewmodel enthält die Logik von Listen\&Perform und hält Attribute die per Databinding an die Viewklassen CountModeView und CountModeActiveView gebunden sind.  Sie implementiert die INotifyPropertyChanged Schnittstelle, um das Erstellen eines Trainingsablaufplans durch den Benutzer in der zugehörigen Viewklasse anzeigen zu können.
\paragraph{Attribute:}
\begin{tabular}{p{7cm}p{10cm}}
+ PropertyChanged: PropertyChangedEventHandler & Der Eventhandler der INotifyPropertyChanged Schnittstelle, bei dem die zugehörige View registriert ist. \\
+ StartActivityCommand: Command & Der Command der beim Drücken des Start Buttons ausgeführt wird, um das Training zu starten. \\
+ StopActivityCommand: Command & Der Command der beim Drücken des Stopp Buttons ausgeführt wird, um das Training zu stoppen. \\
+ PushUpCounter: int & Zähler für aktuell ausgeführte Liegestütze. \\
+ SitUpCounter: int & Zähler für aktuell ausgeführte Sit-ups. \\
+ PushUpResult: int & Zähler für insgesamt während des aktuellen Trainings ausgeführte Liegestütze. \\
+ SitUpResult: int & Zähler für insgesamt während des aktuellen Trainings ausgeführte Sit-ups. \\
+ timer: Stopwatch & Der Timer, welcher die Trainingsdauer des Nutzers misst. \\
+ Minutes: String & Anzahl Minuten der Trainingszeit. \\
+ Seconds: String &  Anzahl Sekunden der Trainingszeit. \\
+ Milliseconds: String & Anzahl Sekunden der Trainingszeit. \\ 
+ ActivityList: ObservableCollection<string> & Liste der Aktivitäten die der Nutzer durchführen möchte, die durch ihn anpassbar ist. \\
+ ActivityAmounts: ObservableCollection<int> & Anzahl der Aktivitäten die der Nutzer durchführen möchte, die durch ihn anpassbar sind. \\
+ SelectedActivity: string & Hilfsattribut zum Bearbeiten und Löschen eines Listeneintrags. Per Databinding an die View gebunden; es ist der Eintrag der Liste auf den der Nutzer zuletzt getippt hat. \\
+ AddActivityCommand: Command & Der Command der beim Drücken des AddActivity Buttons ausgeführt wird. \\
+ RemoveActivityCommand: Command & Der Command der beim Drücken des RemoveActivity Buttons ausgeführt wird. \\
+ EditActivityCommand: Command & Der Command der beim Drücken des EditActivity Buttons ausgeführt wird. \\
\end{tabular}
\paragraph{Methoden:}
\begin{tabular}{p{7cm}p{10cm}}
+ <<create>> ListAndPerformViewmodel & Konstruktor, in dem die Commands definiert und die Instanz des Service Managers zugewiesen werden. Die ActityList und ActivityAmounts werden initialisiert.\\
\# OnPropertyChanged(): void & Methode die beim Eintritt des PropertyChanged Events aufgerufen wird. Sie verändert bei der registrierten View Klasse die Anzeige der ausgewählten Aktivitäten sowie deren Anzahl. \\
+ StartActivity(): void & Methode die vom StartActivityCommand aufgerufen wird, die zur ListenAndPerformActiveView wechselt. Ruft für jeden Listeneintrag in ActivityList nacheinander die DoActivity Methode auf, bis die Liste abgearbeitet ist. \\
+ StopActivity(): void & Methode die vom StopActivityCommand aufgerufen wird. Hält den Timer an und zeigt ein PopUp mit der Anzahl der ausgeführten Aktivitäten an, welches der Nutzer wegklicken kann. Danach wird zum ListenAndPerformView zurück gewechselt. \\
+ startTimer(): void & Startet den Timer. \\
+ stopTimer(): void & Stoppt den Timer. \\
+ DoActivity(): void &  Holt sich  beim Service Manager den ActivityManager, der die entsprechende Activity der ActivityList zur Verfügung stellt, bei dem das Viewmodel seine OnActivityDone Event Methode registriert. Liest die Activity vor und startet den Timer. Nach Erkennung der vorher festgelegten Anzahl Wiederholungen, meldet das Viewmodel seine OnActivityDone Methode ab und zählt den entsprechenden ResultCounter um die ausgeführte Anzahl hoch. \\
+ AddActivity(): void &  Methode die vom AddActivityCommand aufgerufen wird. Ein Popup erscheint, bei dem der Nutzer auf Liegestütze, Situp oder Pause drücken kann. Nach dem Bestätigen wird erscheint ein neues Popup mit der Anzahl. Die Auswahl wird zu den jeweiligen Listen hinzugefügt. \\
+ RemoveActivity(): void &  Methode die vom RemoveActivityCommand aufgerufen wird. Der gehaltene SelectedActivity Eintrag wird entfernt. \\
+ EditActivity(): void & Methode die vom EditActivityCommand aufgerufen wird. \\
+ OnActivityDone(sender: object, EventArgs.Empty) & Event Methode, die von der Aktivität bei Erkennung der Ausführung von einer Wiederholung aufgerufen wird. Sie erhöht den jeweiligen Counter um 1.  \\
+ showPopUp(): void & Zeigt das PopUp mit dem Vorgangsresultat asynchron an, wegklickbar mit einem Button. \\
+ SpeakNextActivity(): void & Liest die nächste Aktivität der ActivityList sowie seine Anzahl asynchron vor. \\
\end{tabular}

\section{Klassenbeschreibung View}
\section{Interaktionsdiagramme}
\subsection{Aktivitätsdiagramm Lauschen und Agieren}
\subsection{Sequenzdiagramme}
%später:
\subsubsection{Abläufe in der App}
Programmstart
Sprache Ändern
\section{Entwurfdaten}
\subsection{Ressourceenverzeichnis}
\subsection{lokale Datenbank}
\subsection{App Properties}

\section{Klassenindex}
%macht valle ganz am Ende oder wir lassen es weg
\section{Anhang}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% END CONTENT %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\printglossaries
\stepcounter{section}


\end{document}